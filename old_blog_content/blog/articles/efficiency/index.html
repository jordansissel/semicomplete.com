+++
# Imported from original pyblosxom .txt format at 2015-08-14
date = "2006-03-24T22:24:15-08:00"
title = "Efficient Computer Usage - Smarter use of your time\n"
# Marked a draft because frankly my old writing may not be worth surfacing again.
# I made bad word choices and had some strong-and-closed opinions years ago.
# We learn over time, eh? :)
draft = true
type = "article"
categories = [ "article" ]
+++

			<h4><a name="id45920">The Mouse</a></h4>
				Everyone uses mice, right? What it really comes down to is how much
				do you use your mouse? Some fanatics may even wonder why you need a
				mouse when wonderful things like keyboard shortcuts exist. So let's
				lay it out like it is: The mouse is a pointing device. You use it to
				indicate where you want actions to occur, usually with a
				<i>click</i> of some sort. How do you know what the consequences 
				of your <i>click</i> are going to be? Certainly you can't use a
				mouse with no eyes, right? How much can you do with a mouse while 
				your eyes are closed?
				<p></p>
				If you are in a Desktop Environment (Windows, KDE, OSX, etc), try
				this exercise using only your mouse (read this through once first):
				<ol>
<li> Open a new browser window (not a tab) </li>
<li> Move your mouse to the bottom left-hand corner of the screen </li>
<li> Close your eyes </li>
<li> Try to close that new browser window </li>
<li> Go back to the the other (this) browser window </li>
<li> View the page source </li>
</ol>

				Were you able to do it? Chances are if you were in Windows and your
				new browser opened up full-screen, then you should be able to do
				atleast the first step, but what about OSX? or KDE? In case you
				failed, here's how it can be
				done in Windows:
				<ul>
<li> If the new browser window opened up maximized, then you are
					in luck! Windows has a GREAT feature that you can click at the
					far, top-right corner of a maximized window and it will close it.
					If you've never noticed this, this allows you to close windows by
					aiming for an easy target, the top-right corner of the screen,
					and clicking. Kudos to Windows for this feature.</li>
<li> Assuming you got that far, the next trick is to figure out
					how to view the page source. With the mouse, there's two options.
					The first is through the main menus (View-&gt;Page Source in
					Firefox). The other is by accessing the context menu for the
					page. The page is a large area you can probably hit blind. Right
					click, now what? Aim down and hope for the best. Right?</li>
</ul>

				The problem with mice is that it requires precise hand-eye
				coordination, or you end up orbiting your intended target until you
				slowly zero-in on the location you intend on pointing at. UGH! My
				favorite example is the Windows calculator (or xcalc for X11). These
				calculators have a similar look-and-feel to normal calculators. If
				you try and "type" numbers using the mouse and the button-based
				number pad, you're doomed to slowness and inefficiency. Use the damn
				keyboard.

				<p></p>

				What mouse-usage comes down to is finding a mouse that suits your
				style of use. There are many kinds of mice: trackballs, touchpads,
				trackpoint (nipple), standard mouse, etc. Try as many as you can,
				figure out which one feels right for you to get the job done best.
			<h4><a name="id45969">The Keyboard</a></h4>
				Don't get me wrong, I love my mouse. I does a great job of pointing
				at things. However, 
				<a href="http://en.wikipedia.org/wiki/Muscle_memory">muscle memory</a>
				is infinitely superior to that of hand-eye coordinated efforts. Why?
				If you can touch type, it's because you have trained yourself such
				that your fingers "know" where the keys are based on where your
				fingers are. The keyboard requires no hand-eye coordination if you
				can do this. The mouse almost always requires hand-eye coordination
				in most environments.
				
				<p></p>

				Notice I said the keyboard requires <i>no</i> hand-eye coordination.
				That's right. zero. You may not have noticed, but most (all?)
				keyboards will have raised indicators on the positions of the
				keyboard where you should place your left and right index fingers.
				If haven't noticed this, lift up your hands and look at the 'F' and
				'J' keys on a standard US keyboard. The bottom of the keys should
				have little nubs. This helps you find the home row without looking,
				simply brilliant.

				<p></p>

				Keyboards have been pretty much the same since QWERTY came around.
				You'll find small differences between manufacturers: Sun keyboards
				have control/caps switched, backspace shifted down one row, tilde
				elsewhere, escape where tilde used to be. Apple makes some keyboards
				with keys half-height keys you almost have to look for before
				attempting to strike them (Requires hand-eye coordination,
				<i>UGH!</i>). Rarer keyboards may vary wildly, but most you'll
				find are similar.

				<p></p>

				There are also two kinds of keyboard "keys" you'll find. There's
				the common, big keys found on standard desktop keyboards. There's
				also laptop-style keyboards with keys that use "shallow scissor"
				keys, which are much shorter have much less travel required to
				press than standard keyboards. Some keyboards you'll find have
				"hotkeys" on them that do magical things such as tweak sound volume
				levels, open your mail client, etc.
			<h4><a name="id46028">Graphical Environment</a></h4>
				You have a mouse, you have a keyboard, what now? Graphical User
				Interfaces have existed for almost 25 years, and still nobody agrees
				on which is the best. The graphical environment provides you
				wonderful toys such as a mouse cursor, and colored icons in your
				file manager. Most graphical environments have fun little widgets
				like buttons, checkboxes, textfields, windows, icons, etc.

				<p></p>

				Your graphical environment probably provides you with a blended
				interface relying on both keyboard and mouse interaction.
				Unfortunately, many things can only be done with the keyboard and
				others can only be done with the mouse. Good graphical interfaces
				will provide both keyboard shortcuts and fast mouse interfaces to
				let you, the user, decide which you want to use.

				<p></p>

				Many graphical environments that use the X window server have some
				neat innovations Apple OSX and Windows lack: 
				<ul>
<li>Grab-and-splat: Applications will have a grab-and-splat style of
				mouse-oriented copy-and-paste. First, you "grab" text by selecting
				it with the mouse. This activity almost always copies the selected
				text to the clipboard, so forget needing to hit
				<code>Control+C</code> or fumble around looking for a "copy" option.
				The "splat" part refers pasting by using a mouse click to indicate a
				paste action. It's always been the middle mouse button in my
				experience..  This lets me copy and paste using only a few clicks
				and no keyboard interaction.</li>
<li>Easy window movement: Most window managers
				I've used allow you to "grab" a window ANYWHERE simply by holding
				the <code>ALT</code> key and dragging a window with the left mouse
				button. OSX and Windows make you hunt for the title bar to drag it.
				This is my favorite feature, ever.</li>
<li>Easy window resizing: Again, many window managers allow you to
				again "grab" the window anywhere. This time, if you use the
				right-mouse button (or middle mouse in GNOME) while holding
				<code>ALT</code> you can drag the window in any direction and it
				will resize the window. Simple and fast.</li>
<li>Mouse-focus: focus-follows-mouse is another of my favorite
				innovations not found easily OSX or Windows. This means that
				whatever menu your mouse is hovering over gets focused, meaning you
				can type in it. This doesn't mean the window gets moved on top of
				others, just that the keyboard events go to it. This is so
				useful.</li>
<li>Bring Forward/Send Back: Windows are in layers. You can put a
				window on top of this browser window, right? Many window managers in
				X allow you to send a window to the bottom layer by using
				<code>alt+rightclick</code>. You can bring a clipped window forward
				by using <code>alt+leftclick</code>
</li>
</ul>

				Nothing quite makes me angry like having to hunt down the title bar
				or the tiny "drag me to resize" widget you find at the bottom-right
				of many OSX applications. No one should have to be that precise with
				the mouse to do simple actions such as resizing or moving a window.
				I wonder why nobody at these big companies has discovered how useful
				these features are. Think about it, what does alt+rightclick+drag do
				in a window in OSX? Nothing, right? Why not make use of it? I should
				mention, however, that Windows XP appears to support mouse focus, or
				<i>sloppy focus</i>, (older versions may too) by flipping some
				options in the registry. TweakUI should be able to enable this for
				you.

			<h4><a name="id46216">Part 2: Tricks</a></h4>
<h4><a name="id46220">Prepare for Irritation</a></h4>
				I mentioned <i>patience</i> being a resource earlier in this article.
				Patience is how much irritation you are willing to put up with in your
				computing environment before taking a baseball bat to your monitor.
				Your mileage may vary, but personally, patience is the first thing I
				lose, and it's the first reason that causes me to find less irritating
				activities. This becomes a huge problem when the activity that is
				wearing on my patience is one that has an impending deadline! When a
				deadline is bearing down on you, you cannot afford to be detered by a
				lack of patience for the computing environment you need to be using to
				complate said activity.

				<p></p>

				Bringing back the <i>Principle of Least Effort</i>, I am wholely
				willing to spend resources (time) when I have nothing better to do.
				This is called boredom. I love learning new things, discovering new
				tricks, etc, so when I have some free time to kill, I often kill it
				learning new tricks or enhancing my personal computing environment.
				This make any required future tasks consume less of my patience,
				allowing me to work better and longer on tasks I need to get done.

				<p></p>

				There are many questions you should ask yourself: How much do you
				know about your preferred computing environment?  What can you do
				quickly? What can't you do quickly? Have you configured said
				environment to your preference? If not, why not? The list goes on
				and on, but the point is, you need to evaluate how you interact with
				your computer and decide if you find it efficient. If it is not
				efficient, find better means by which to interact. This means
				experimenting with software tools, learning keyboard shortcuts,
				tweaking interface options, and more.
			<h4><a name="id46236">Keyboard Shortcuts</a></h4>
				Seeing as how muscle memory is faster than hand-eye coordination,
				you should do your best to learn all the keyboard shortcuts you
				can. This means reading documentation, taking mental notes of
				keyboard shortcuts when using the popup and main menu systems, and
				even making your own keyboard shortcuts if the program allows.
				Using <code>Control+V</code> to paste is always more efficient than
				fumbling around with your mouse to find the paste button or
				invoking a context menu and finding the paste option. 
			<h4><a name="id46245">Mouse Gestures</a></h4>
				Mouse gestures are fantastic if your hand is glued to your mouse
				most of the time. This is especially useful when you are using a
				mouse-driven piece of software, such as a graphical file browser or
				a web browser (such as Opera). I equate mouse gestures to the
				rodent-version of keyboard shortcuts. They're efficient and can
				quickly become muscle-memory reactions. Unfortunately, many programs
				do not support them. <a href="http://www.opera.com">Opera</a> is an
				ad-supported web browser that supports mouse gestures by default.
				Firefox has extensions you can install to add mouse gesture support.

				<p></p>

				Mouse gestures are just that, gestures you make with your mouse
				pointer. A short horizontal movement to the left while holding the
				right mouse button may indicate that you want to go <i>Back</i> in
				your web browser, for example. Mouse gestures are great, and can
				often be combined with keyboard combinations; for instance, holding
				shift while holding the left button and dragging the mouse upward.
				The only problem with mouse gestures is that they are not easily
				discovered, that means that you'll probably have to read the
				documentation to figure out what the available mouse gestures are
				and what they do. Fortunately, many programs that do support
				gestures support configurability of those gestures. This means you
				can make things like "copy text" and other common tasks execute when
				you perform certain gestures. Fantastic!

				<p></p>

				There's problems with mouse gestures, however. They only seem to be
				truely useful with standard mice, for myself anyway. I use a
				trackpoint (nipple) mouse, so directional precision is somewhat
				difficult to maintain when moving quickly. That means my attempt to
				"click-drag right" may end up turning into "click-drag down-right"
				depending on how error I make. Your mileage may vary.
			<h4><a name="id46297">Pie Menus</a></h4>
				Pie menus, also known as radial menus, are extremely useful elements
				of mouse-driven software. I consider them to be graphical relatives
				of mouse gestures. While mouse gestures are simply mouse movements,
				radial menus have important graphical hints which make learning them
				very quick. These types of menus are circular instead of your normal
				rectangular, list-style, menuing systems. You are presented with a
				circular menu with a few choices, if the item you chose has a
				submenu, then selecting that submenu will bring another circle out
				so you can choose elements from that submenu. The cool thing is most
				implementations I've seen of this allow you to indicate submenu
				selection by simply mousing in the direction of the submenu. Fast
				and easy to learn? I like it.
			<h4><a name="id46302">Keyboard Mapping</a></h4>
				What's a keyboard map? It's a table that your Operating System uses
				to determine what key you pressed. Your keyboard sends a numeric
				identifier for whatever key you pressed. This numeric identifier is
				looked up the keyboard map table and is translated into a key press
				that applications can recognize. This is a critical point to
				understand. This map can be altered to make different keys act
				however you please. One common alteration is to make the <code>Caps
				Lock</code> key act like a <code>Control</code> key. Who uses
				<code>Caps Lock</code> these days anyway? 
			<h4><a name="id46387">Part 3: Tools</a></h4>
			Your tool/accessory options are limited to the kind of computing you
			do. Certain software tools are available for X that aren't available in
			Windows or OSX. The alternates are also true. This boils down to the
			fact that if you want to make yourself more productive on a computer,
			you're going to need to find the tools which give you a productive
			edge.

			<h4><a name="id46391">Windows</a></h4>
				I know of only two utilities that help you modify useful parts of
				the Windows interface, they are below. If you know of more, please
				let me know.
				<ul>
<li><a href="http://download.microsoft.com/download/f/c/a/fca6767b-9ed9-45a6-b352-839afb2a2679/TweakUiPowertoySetup.exe">TweakUI</a></li>
<li><a href="http://webpages.charter.net/krumsick/"> KeyTweak </a></li>
</ul>

				You can probably find more by googling for "windows tweaks" or
				somesuch. I don't use Windows anymore, so you're on your own :)
			<h4><a name="id46417">Apple OS X</a></h4>
				I hate Macs, therefore this is a very thin section. Perhaps you
				should email me with software/tool suggestions and descriptions?

				<ul>
<li>
<a href="http://quicksilver.blacktree.com/">quicksilver</a>: a trainable launcher system </li>
<li>
<a href="http://www.obdev.at/products/launchbar/">launchbar</a>: another launcher </li>
<li>
<a href="http://the.taoofmac.com/space/LiteSwitch">LiteSwitch</a>: an windows-like alt-tab replacement that has many useful features.</li>
</ul>
<h4><a name="id46452">X-Windows</a></h4>
<ul>
<li>
<a href="http://www.jwz.org/xkeycaps">xkeycaps</a> - a
				fantastic program that lets you remap keys on the fly in X11 
				and save the changes.</li>
<li>
<a href="http://apwal.free.fr/">apwal</a> - launcher
				application that puts icons near your cursor when executed. Choosing
				an icon executes it's program. Fully configurable, I like this idea</li>
</ul>
<h4><a name="id46480">Part 4: My Environment</a></h4>
			Again, I'll mention muscle memory is fast. So I tend towards
			environments that lend themselves to activities that can be learned in
			muscle meory. What do I use? Anything that's mostly driven by the
			keyboard.
			<p></p>

			Right, so let's get down to it. What do I use in my environment?
			<p></p>
<ol>
<li>
			The first thing I usually do when configuring an environment to my
			preferences is changing the <code>Caps Lock</code> key to act like a
			<code>Control</code> key. <b>Caps Lock is useless!</b> Other keymap
			changes may also occur: sometimes I map F1 to escape, for example. Or
			right-alt to windows key.
			</li>
<li>
			The next thing I do is get familiar software and configure it. If you
			don't configure software you use commonly to suit your needs, then you
			probably aren't using it as efficiently as you could. The first thing
			when I login to a new system is copy my rc files (zshrc, vimrc, etc)
			over.
			</li>
</ol>

			Once those two tasks are done, I'm pretty much set to be comfortable
			and efficient. However, you might ask what particular software and
			configurations do I use? I'll start with vi.

			<h4><a name="id46510">editor: vi</a></h4>
<ul>
<li> Comes standard in some flavor on almost every unix-like os </li>
<li> Extremely muscle-memory friendly </li>
<li> Very configurable (depends on flavor) </li>
</ul>

				I've been using vi since I started using anything unix-like. This
				was about 4 years ago. For those out of the loop, vi is a
				keyboard-oriented text editor that comes in many flavors. The
				principle behind vi is it's two-mode style of interface. In
				<i>insert</i> mode, you can type into your document as you would any
				other editor. However, if you hit Escape while in <i>insert</i>
				mode, it puts you in <i>command</i> mode. <i>Command</i> mode
				presents the user with many different kinds of editing and movement
				commands with single keystrokes. This gives you a rediculously
				powerful editing system that is also very fast to use. The only
				caveat is that there is a steep learning curve, becuase the
				interface is far from intuitive.
				<p></p>

				If you spend the time to learn any vi commands you can, you'll begin
				editing text faster and faster. The more commands you know, the more
				effectively you can use the editor. The more often you use these
				commands, the faster they are learned in muscle memory.
				<p></p>

				vi comes in many flavors. The most popular open source ones being
				nvi and vim. Both are very configurable and allow you to change most
				behavioral aspects of the editor. Vim has far more features than can
				be described here along with very extensive documentation.

				<p></p>

				A nice benefit to knowing vi commands by heart is that many unix
				shells sport vi-compatibility modes. Bash, zsh, tcsh, and ksh all
				have vi-style input modes which let you line-edit with vi commands.
				This is quite sexy and makes line editing in the shell faster.
			<h4><a name="id46549">window manager: ion</a></h4>
				Over the past 4 years of my unix experience, I've used many
				different window managers. I started using WindowMaker then moved
				to BlackBox and others. All of those window managers were very mouse
				oriented and made much more efficient use of the mouse than Windows
				ever has.
				<p></p>

				Enter ion. Ion is designed to be used primarily with the keyboard.
				It's original implementation was based around "tiling" workspaces
				and tabbed frames. Workspaces are split into frames that client
				windows (xterm, etc) can be launched into. Frames can contain
				multiple clients, discernable by tabbed title bars. Ion does what I
				believe a window manager should do: manage windows. With the normal
				framed workspace layouts, I never have to worry about where windows
				are goign to show up. I never have to move windows around myself to
				make them fit on the screen better, etc. Most of the effort required
				in using a graphical windowing environment is handled automatically
				by the window manager.
				<p></p>

				Ion has grown over the years and now supports things like floating
				workspaces (they act like normal workspaces you're used to using)
				among many other features. It's greatest benefit is that most of the
				window manager's features are accessible through it's scripting
				engine, Lua. It supports neat things like winprop kludges so you can
				tell ion what it should do with certain kinds of programs and
				windows. 
				<p></p>

				Just about everything can be configured, from themes to
				keybindings. The default settings are reasonably sane and learning
				how to use it is fairly simple as there's a lot of documentation
				online. If you browse through the keybinding config files that come
				with it, you can quickly learn how to use this window manager.
			<h4><a name="id46595">Utilities, tools, and bears?! Oh My!</a></h4>
				Ok, so maybe I exagerated a bit when I said bears. At any rate,
				Making effective use of your time depends wholely on the tools you
				have available. There's a saying: "When all you have is a hammer,
				everything looks like a nail." This is a very unfortunate truth.

				<p></p>
				Most of us just want to get the jobs done and move on with our
				lives. The problem is, that this attitude is a hinderance. You need
				to acquire the proper tools to get a job done to satisfaction. If
				you are lacking in the proper tools, find them or make your own.
				You'll enjoy free time later when you didn't half-ass something only
				to have it not quite fit.

				<p></p>
				Many friends have pointed out that I "obviously" hate graphical
				interfaces the only programs I use are console-based (with one
				exception, Firefox). Whether I do or not is out of the scope of this
				article. The point is, I use primarily console based applications
				becuase the tasks I need to perform are most easily suited to my use
				of these applications which happen to be console based.

				<p></p>
				There's ultimately a chicken and egg problem here. You don't know
				what tools you need until there's a job to be done. Hopefully, your
				OS comes with a standard set of useful tools. Unfortunately, many of
				the fanboy fad Linux distros lack almost all useful tools by
				default. I'm sorry if you're running one of them.
			<h4><a name="id46608">Part 5: Conclusions</a></h4>
			Learn the tools you need to use, and learn them well. This follows no
			matter what hat you are wearing: student, full time employee, open
			source developer, etc. The better you understand and can use the tools
			you need to interact with, the more efficiently you are able to work.
			Working more efficiently lets you work faster and smarter. This has
			great benefits to yourself, your peers and your employer(s).
		</div>
